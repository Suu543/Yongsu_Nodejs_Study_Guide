# Mongoose: Validation

- When defining a schema, you can set the type of a property to a SchemaType object. You use this object to define the validation requirements for the given property.

```javascript
// Adding validation
new mongoose.Schema({
  name: { type: String, required: true }
});
```

- Validation logic is executed by Mongoose prior to saving a document to the database. You can also trigger it manually by calling the validate() method
- Built-in validators:
  - Strings: <b>minlength, maxlength, match, enum</b>
  - Numbers: <b>min, max</b>
  - Dates: <b>min, max</b>
  - All types: <b>required</b>

```javascript
tags: [
    type: Array,
    validate: {
        validator: function(v) {return v && v.length > 0;},
        message: 'A course should have at least 1 tag."
    }
]

// If you need to talk to a database or a remote service to perform the validation, you need to create an async validator:

validate: [
    isAsync: true,
    validator: function(v, callback) {
        // Do the validation, when the result is ready, call the callback
        callback(isValid);
    }
]

// Other useful SchemaType properties:
// - Strings: lowercase, uppercase, trim
// - All types: get, set (to define a custom getter/setter)

price: {
    type: Number,
    get: v => Math.round(v),
    set: v => Math.round(v)
}
```

# Mongoose: Modelling Relationships between Connected Data

- To model relationships between connected data, we can either reference a document or embed it in another document.

- When referencing a document, there is really no relationship between these two documents. So it is possbile to reference a non-existing document.

- Referencing documents (normalization) is a good approach when you want to enforce data consistency. Because there will be a single instance of an object in the database. But this approach has a negative impact on the performance of your queries because in MongoDB we cannot <b>JOIN</b> documents as we do in relational databases. So, to get a complete representation of a document with its related documents, we need to send multiple queries to the database.

- Embedding documents (denormalization) solves this issue. We can read a complete representation of a document with a single query. All the necessary data is embedded in one document and its children. But this also means we'll have multiple copies of data in different places. While storage is not an issue these days, having multiple copies means changes made to the original document may not propagate to all copies. If database server dies during an update, some documents will be inconsistent. For every business, for every problem, you need to ask this question:
- "Can we tolerate data being inconsistent for a short period of time?" If not, You'll have to use references. But again, this means that your queries will be slower.

```javascript
// Referencing a document
const courseSchema = new mongoose.Schema({
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Author"
  }
});

// Referencing a document
const courseSchema = new mongoose.Schema({
  author: {
    type: new mongoose.Schema({
      name: String,
      bio: String
    })
  }
});

// Embedded documents don't have a save method. They can only be saved in the context of their parent.
```

```javascript
// Updating an embedded document
const course = await Course.findById(courseId);
course.author.name = "New Name";
course.save();
```

- We don't have transactions in MongoDB. To implement transactions, we use a pattern called <b>"Two Phase Commit"</b>. If you don't want to manually implement this pattern, use the <b>Fawn</b> NPM package:

```javascript
// Implementing transactions using Fawn
try {
    await new Fawn.Task()
        .save('rentals', newRental)
        .update('movies', {_id: movie._id, {$inc: numberInStock: -1}})
        .run();
}

catch(ex) {
    // At this point, all operations are automatically rolled back.
}
```

- <b>ObjectIDs</b> are generated by MongoDB driver and are used to uniquely identify a document. They consist of 12 bytes:
- 4 bytes: timestamp
- 3 bytes: machine identifier
- 2 bytes: process identifier
- 3 bytes: counter

- ObjectIDs are almost unique. In theory, there is a chance for two ObjectIDs to be equal but the odds are very low (1/16,000,000) for most real-world applications.

```javascript
// Validating ObjectIDs
mongoose.Types.ObjectID.isValid(id);
```

- To validate ObjectIDs using <b>joi</b>, use <b>joi-objectid</b> NPM
